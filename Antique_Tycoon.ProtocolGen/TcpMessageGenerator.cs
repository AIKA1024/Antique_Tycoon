using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Antique_Tycoon.ProtocolGen;

[Generator]
public sealed class TcpMessageGenerator : IIncrementalGenerator
{
  public void Initialize(IncrementalGeneratorInitializationContext context)
  {
    var messages = context.SyntaxProvider
      .CreateSyntaxProvider(
        static (node, _) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
        static (ctx, _) => TryGetTcpMessageSymbol(ctx, out var symbol) ? symbol : null
      )
      .Where(static s => s is not null)
      .Select(static (s, _) => s!)
      .Collect();

    context.RegisterSourceOutput(messages, GenerateAll);
  }

  private static void GenerateAll(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> messages)
  {
    if (messages.IsDefaultOrEmpty) return;

    // 务必记得去重并排序，防止生成不稳定的代码
    var ordered = messages
      .Distinct(SymbolEqualityComparer.Default)
      .Cast<INamedTypeSymbol>()
      .OrderBy(m => m.Name, StringComparer.Ordinal)
      .ToList();

    GenerateEnum(context, ordered);
    // GenerateJsonContext(context, ordered); // <--- 这行删掉或注释
    GenerateRegistry(context, ordered); // <--- 这一行必须保留！
  }

  // ... TryGetTcpMessageSymbol 方法保持不变 ...
  private static bool TryGetTcpMessageSymbol(GeneratorSyntaxContext ctx, out INamedTypeSymbol? symbol)
  {
    symbol = null;
    if (ctx.Node is not ClassDeclarationSyntax cds) return false;

    var declared = ctx.SemanticModel.GetDeclaredSymbol(cds);
    if (declared is not INamedTypeSymbol named) return false;

    foreach (var attr in named.GetAttributes())
    {
      if (attr.AttributeClass?.Name == "TcpMessageAttribute")
      {
        symbol = named;
        return true;
      }
    }

    return false;
  }

  // ---------------- ENUM (保持不变) ----------------
  private static void GenerateEnum(SourceProductionContext context, List<INamedTypeSymbol> messages)
  {
    var sb = new StringBuilder();
    sb.AppendLine("namespace Antique_Tycoon.Models.Net.Tcp;"); // 确认命名空间
    sb.AppendLine();
    sb.AppendLine("public enum TcpMessageType : ushort");
    sb.AppendLine("{");
    ushort id = 1;
    foreach (var msg in messages)
    {
      sb.AppendLine($"    {msg.Name} = {id},");
      id++;
    }

    sb.AppendLine("}");
    context.AddSource("TcpMessageType.g.cs", sb.ToString());
  }

  // ---------------- REGISTRY (确认这里的引用和逻辑) ----------------
  private static void GenerateRegistry(SourceProductionContext context, IEnumerable<INamedTypeSymbol> messages)
  {
    var sb = new StringBuilder();

    // 用于构建 Type -> Enum 的条目
    var sbTypeMapEntries = new StringBuilder();
    // 用于构建 Enum -> Type 的条目
    var sbEnumMapEntries = new StringBuilder();

    foreach (var msg in messages)
    {
      string fullTypeName = msg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
      string enumName = msg.Name; // 假设枚举名和类名一致
      // 指向我们之前生成的 ProtocolJsonContext
      string jsonInfo = $"Antique_Tycoon.Models.Json.AppJsonContext.Default.{enumName}";

      // 1. 构建 Type 映射条目
      sbTypeMapEntries.AppendLine(
        $@"                [typeof({fullTypeName})] = (TcpMessageType.{enumName}, {jsonInfo}),");

      // 2. 构建 Enum 映射条目 (新增)
      sbEnumMapEntries.AppendLine(
        $@"                [TcpMessageType.{enumName}] = (typeof({fullTypeName}), {jsonInfo}),");
    }

    // --- 开始生成文件内容 ---
    sb.AppendLine("// <auto-generated />");
    sb.AppendLine("using System;");
    sb.AppendLine("using System.Collections.Generic;");
    sb.AppendLine("using System.Text.Json.Serialization.Metadata;");
    sb.AppendLine("using Antique_Tycoon.Models.Net.Tcp;"); // 引用你的枚举和Context命名空间
    sb.AppendLine();
    sb.AppendLine("namespace Antique_Tycoon.Net");
    sb.AppendLine("{");
    sb.AppendLine("    public static class TcpMessageRegistry");
    sb.AppendLine("    {");

    // 定义两个字典
    sb.AppendLine(
      "        private static readonly Dictionary<Type, (TcpMessageType Type, JsonTypeInfo Info)> _typeMap;");
    sb.AppendLine(
      "        private static readonly Dictionary<TcpMessageType, (Type Type, JsonTypeInfo Info)> _enumMap;"); // 新增

    // 静态构造函数
    sb.AppendLine("        static TcpMessageRegistry()");
    sb.AppendLine("        {");

    // 初始化 Type Map
    sb.AppendLine("            _typeMap = new Dictionary<Type, (TcpMessageType, JsonTypeInfo)>");
    sb.AppendLine("            {");
    sb.Append(sbTypeMapEntries);
    sb.AppendLine("            };");

    // 初始化 Enum Map (新增)
    sb.AppendLine("            _enumMap = new Dictionary<TcpMessageType, (Type, JsonTypeInfo)>");
    sb.AppendLine("            {");
    sb.Append(sbEnumMapEntries);
    sb.AppendLine("            };");

    sb.AppendLine("        }"); // End static constructor

    // --- Get 方法 (通过 Type 获取) ---
    sb.AppendLine("        /// <summary>通过类型获取枚举和Json信息</summary>");
    sb.AppendLine("        public static (TcpMessageType tcpMessageType, JsonTypeInfo jsonTypeInfo) Get(Type type)");
    sb.AppendLine("            => _typeMap[type];");

    // --- Get 方法 (通过 Enum 获取 - 新增重载) ---
    sb.AppendLine("        /// <summary>通过枚举获取类型和Json信息</summary>");
    sb.AppendLine("        public static (Type type, JsonTypeInfo jsonTypeInfo) Get(TcpMessageType messageType)");
    sb.AppendLine("            => _enumMap[messageType];");

    sb.AppendLine("    }"); // End class
    sb.AppendLine("}"); // End namespace

    context.AddSource("TcpMessageRegistry.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
  }
}